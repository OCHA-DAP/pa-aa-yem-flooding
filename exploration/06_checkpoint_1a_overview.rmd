---
title: "06_clustering events"
output: 
    html_document:
        toc: true
        toc_float: true
        toc_depth: 4
date: "2023-03-22"
---

```{r setup, include=FALSE}
# knitr::opts_chunk$set(echo = FALSE,
#                       include =T,
#                       warning=F,
#                       message = F,comment = F)

knitr::opts_chunk$set(echo = FALSE, warning=FALSE,message = FALSE)
```
## Intro
```{r, echo=F,include=T}
# source libs & funcs
library(here)
library(targets)
library(sf)
library(tidyverse)
library(leaflet)
library(glue)
library(gghdx)
library(lubridate )
library(sysfonts)
library(extRemes)
library(ggiraph)
tar_source()
font_add_google("Source Sans Pro")
showtext::showtext_auto()

# source targets needed for notebook.
tar_load(cccm_flood_impact_data)
tar_load(cccm_flood_impact_data_w_coords)
tar_load(rainfall_impact_tbl)
tar_load(gov_area_rainfall_impact_tbl)
tar_load(zonal_stats_high_risk_hull)

coord_lookup <- cccm_flood_impact_data_w_coords %>% 
    distinct(site_id, lon, lat)

roi<- rainfall_impact_tbl %>%
    left_join(coord_lookup, by ="site_id") %>%
    filter(governorate_name %in% c("Marib","Hajjah"),fevent)




cccm_impact_c1 <- cccm_flood_impact_data_w_coords %>% 
    group_by(governorate_name, site_name, site_id, lon, lat,date= date_of_episode) %>% 
    summarise(
        across(starts_with("num_"),~mean(.x,na.rm=T)),.groups="drop"
    ) %>% 
    filter(site_id !="YE1712_0643",
           governorate_name %in% c("Marib","Hajjah")
    )

unique_event_dates<- roi %>% 
    distinct(governorate_name,date) %>% 
    split(.$governorate_name)

```

For an **Area-Based Approach** we are define the area at the Governorate level. We have decided to focus on **Marib** and **Hajjah**. 

To do this we aggregated rainfall and impact/event data to the governorate level. We did this by taking the daily `mean()` and `max()` precipitation (for all precip regimes) across all sites. Then if an event was reported in any site we said that an event occurred in the governorate. By doing this we basically created governorate level summary table to use for performance analysis.

I can see an argument that this approach is flawed as a great deal of the event dates were basically consecutive and it's likely that they should be grouped as 1 event.The plots below highlight this. 

- red lines are reported events
- I overlaid black lines to mark the start of the run of "consecutive" runs (classified as TPs)
- threshold of 25 mm just used for illustrative purposes.

```{r}
p_rainfall_events_gov <- c("Hajjah","Marib") %>% 
    map(
        \(gov){
            plot_site_events_classified(df=gov_area_rainfall_impact_tbl %>% 
                                            filter(governorate_name ==gov),
                                        x = "precip_roll10_mean",
                                        event = "fevent",
                                        thresh = 25,
                                        day_window = 60,
                                        plot_title = gov
                                        )
        }
    )
```

```{r, out.width="100%"}
walk(p_rainfall_events_gov,~print(.x))
```

I think this argument does make some sense and it likely does skew some of the performance graphs. We could theoretically just include the start of the runs in our performance analysis. However, I feel like we are just throwing out good data if we do that and there is a justification to try to keep more of that data in. Perhaps the best approach would be to group events based on space and time.


## Rainfall overview

Monthly rainfalls

```{r, eval =T}
# zonal_stats_high_risk_hull$roll30 %>% 
#     ggplot(aes(x= as_date(date),y = mean, color=governorate_name))+
#     geom_line()+
#     labs(x= "date", y= "precip (30 day mm)")+
#     theme_hdx()

zonal_stats_high_risk_hull$precip_daily %>% 
    mutate(date= as_date(date)) %>% 
    group_by(year=year(date),month=month(date), governorate_name) %>% 
    summarise(
        monthly_rainfall =sum(mean),.groups = "drop"
        
    ) %>% 
    mutate(
     date=   paste0(year,"-",formatC(month, width=2, flag="0"),"-01")
    ) %>% 
    ggplot(aes(x= as_date(date),y = monthly_rainfall, color=governorate_name))+
    geom_line(alpha=0.6)+
    labs(x= "date", y= "Monthly total (mm)")+
    scale_x_date(breaks="year",date_labels = "%b-%y" )+
    theme_hdx()+
    theme(axis.text.x = element_text(angle=90))
```

Yearly rainfall

```{r}

zonal_stats_high_risk_hull$precip_daily %>% 
    mutate(date= as_date(date)) %>% 
    group_by(year=year(date), governorate_name) %>% 
    summarise(
        yearly_rainfall =sum(mean),.groups = "drop"
        
    ) %>% 
    ggplot(aes(x= year,
               y = yearly_rainfall, color=governorate_name))+
    geom_line(alpha=1)+
    scale_x_continuous(breaks=seq(1981,2022, by =1))+
    labs(x= "year", y= "yearly total ( mm)")+
    theme_hdx()+
    theme(axis.text.x = element_text(angle=90))
```


## Clustering


```{r}
coord_lookup <- cccm_flood_impact_data_w_coords %>% 
    distinct(site_id, lon, lat)

hajjah_site_level <- rainfall_impact_tbl %>%
    left_join(coord_lookup) %>% 
    filter(governorate_name=="Hajjah")
    


kmeans_cluster_events <-  function(df,
                                   date,
                                   lon,
                                   lat,
                                   event=NULL,
                                   k=5,
                                   scale=F){
    if(!is.null(event)){
       df_event <- df %>% 
        filter(!!sym(event))  
    }
    # if no event column listed then they are all events -- good to have this flexibility for 
    # different data sets int this analysis
    if(is.null(event)){
        df_event <- df
    }
    
    df_sel <- df_event %>% 
            mutate(
                date= as.numeric(date)
            ) %>% 
            select(date, lon, lat) 
    
    if(scale){
       df_sel <- df_sel  %>% 
        mutate(
            across(
                everything(),~scale(.x,center=T, scale=T)
                )
        )
    }
        matrix_input <- df_sel %>% 
            as.matrix()
        set.seed(100)
        km <-  kmeans(matrix_input,centers= k,nstart = 20)
        df_event$cluster <-as.character(km$cluster)
        return(df_event)
}


```


To do this we have to go back to thinking at site level and cluster events based on the the individual event dates and locations.

Looking at just **Marib** and **Hajjah**. We see the following see that Marib and Hajjaah have **`r nrow(unique_event_dates$Marib)`** , and **`r nrow(unique_event_dates$Hajjah)`**, respectively.

Let's see if we can cluster based on coordinates and date of event. As the governorates are separated geographically let's do the clustering separately.

```{r,echo=F, include=T}

spatial_pt_clusters <- function(df = df,
                                     date = "date",
                                     lon = "lon",
                                     lat = "lat",
                                     event = "fevent",
                                scale = F,
                                     k= k){
    split(df,df$governorate_name) %>% 
    imap(\(df,nm){
        
        km <-  kmeans_cluster_events(df = df,
                                     date = date,
                                     lon = lon,
                                     lat = lat,
                                     event = event,scale = scale,
                                     k= k)
        df$cluster <- paste0(nm,"_",as.character(km$cluster))
        df_sf <-  st_as_sf(df,
                           coords = c("lon","lat"),
                           crs= 4326
        ) %>% 
            st_jitter(amount = 0.05)
        df_sf$labels <-  paste0(
            "Site_ID:", df_sf$site_id,
            "<br> date:",df_sf$date,
            "<br> cluter:", df_sf$cluster
        ) %>% lapply(htmltools::HTML)

        return(df_sf)
    }
    )
}
map_pt_clusters <- function(df ,
                            date = "date",
                            lon = "lon",
                            lat = "lat",
                            event = "fevent",scale = F,
                            k= k){
    
    pts_clustered <- spatial_pt_clusters(df= df,
                                         date=date,
                                         lon=lon, 
                                         lat=lat,
                                         event=event, 
                                         scale=scale,
                                         k=k)
    pal_hajjah <- colorFactor(palette = "Dark2", domain = pts_clustered$Hajjah$cluster)
    pal_marib<- colorFactor(palette = "Accent", domain = pts_clustered$Marib$cluster)
    
    leaflet() %>% 
    addProviderTiles(provider = leaflet::providers$Stamen.Toner) %>% 
    # addPolygons(data=grid,fill=NA) %>%
     addCircleMarkers(data= pts_clustered$Hajjah,
                popup = ~cluster, 
                label = ~labels,
                # clusterOptions = markerClusterOptions(),
                color = ~pal_hajjah(cluster)
             ) %>% 
     addCircleMarkers(data= pts_clustered$Marib,
                popup = ~cluster, 
                label = ~labels,
                # clusterOptions = markerClusterOptions(),
                color = ~pal_marib(cluster)
             )
}
    


# spatial_pt_clusters(df = df,
#                                      date = "date",
#                                      lon = "lon",
#                                      lat = "lat",
#                                      event = "fevent",scale = T,
#                                      k= k
# # going to quickly make a 2 grid networks roughly the size of chirps for visual
# grid<- pts_clustered_k5 %>% 
#     map(\(sfdf){
#         sfdf %>% 
#             st_bbox() %>% 
#             st_as_sfc() %>% 
#             st_transform(crs= 2089) %>% 
#             st_make_grid(cellsize = 5500) %>% 
#             st_transform(crs= 4326) %>% 
#             st_as_sf()
#     }
#     ) %>% 
#     bind_rows()


```


### Cluster Maps

Below are maps of the sites clustered - I've jittered the points by 0.05 so that you it's easier to see the sites that are very close to one another. You can **zoom and hover** the sites for more details.

First we have the sites in **7 clusters**
```{r,echo=F,include=T,out.width="100%"}
map_pt_clusters(df = roi,date = "date",lon = "lon","lat",event = "fevent",scale = F,k = 7) %>% 
    addScaleBar()
```

Below we have the sites grouped into **5 clusters**
```{r,echo=F, include =T,out.width="100%"}
map_pt_clusters(df = roi,date = "date",lon = "lon","lat",event = "fevent",scale = F,k = 5) %>% 
    addScaleBar()
```


we do see that weird outlier down south -- in the DB it's recorded as Hajjah. Let's remove it and see if that affects the clustering. Here are the 7 clusters again:
```{r}
map_pt_clusters(df = roi %>% 
                     filter(site_id !="YE1712_0643") ,
                date = "date",
                lon = "lon",
                "lat",
                event = "fevent",
                scale = F,
                k = 7) %>% 
    addScaleBar()

```

and the 5 clusters again:
```{r}
map_pt_clusters(df = roi %>% 
                     filter(site_id !="YE1712_0643") ,
                date = "date",
                lon = "lon",
                "lat",
                event = "fevent",
                scale = F,
                k = 5) %>% 
    addScaleBar()

```

There are some spatial patterns evident, for example in the previous map you see `Hajjah_1` does seem to cluster up in the north. However, when you zoom in and inspect in greater detail you do see `Hajjah_1` also well distributed down south. To me, these maps indicate that the spatial aspect may be less important than the timing. This might actually be good for us as we are trying to design 1 threshold per governorate.


Let's plot the clusters along a time series to get a better understanding of the events timing
```{r,eval=F}


df_clusters5 <- spatial_pt_clusters(df = roi %>% 
                     filter(site_id !="YE1712_0643") ,
                date = "date",
                lon = "lon",
                "lat",
                event = "fevent",
                scale = T,
                k = 5)
df_clusters7 <- spatial_pt_clusters(df = roi %>% 
                     filter(site_id !="YE1712_0643") ,
                date = "date",
                lon = "lon",
                "lat",
                event = "fevent",
                scale = T,
                k = 7)

p_clusters5 <- df_clusters5 %>% 
    imap(\(dfsf,nm){
        dfsf %>% 
            st_drop_geometry() %>% 
            distinct(date,site_id,cluster) %>% 
            left_join(y = cccm_flood_impact_data %>%
                          group_by(site_id, date=date_of_episode) %>% 
                          summarise(
                              across(starts_with("num_"),~mean(.x,na.rm=T))
                          ) ,
                      by = c("site_id"="site_id","date"="date")) %>% 
            ggplot(aes(x=date,y=num_shelters_affected,color=cluster))+
            geom_point()+
            labs(y="Number affected Shelters",
                 title = "Clustering of events based on timing and coordinates",
                 subtitle = glue("Yemen - {nm} -5 clusters"))+
            theme_hdx()
        
    })
p_clusters7 <- df_clusters7 %>% 
    imap(\(dfsf,nm){
        dfsf %>% 
            st_drop_geometry() %>% 
            distinct(date,site_id,cluster) %>% 
            left_join(y = cccm_flood_impact_data %>%
                          group_by(site_id, date=date_of_episode) %>% 
                          summarise(
                              across(starts_with("num_"),~mean(.x,na.rm=T))
                          ) ,
                      by = c("site_id"="site_id","date"="date")) %>% 
            ggplot(aes(x=date,y=num_shelters_affected,color=cluster))+
            geom_point()+
            labs(y="Number affected Shelters",
                 title = "Clustering of events based on timing and coordinates",
                 subtitle = glue("Yemen - {nm} -7 clusters"))+
            theme_hdx()
        
    })
```


```{r,eval=F,out.width="100%"}
# Below are the **7 clusters** plotted against **Number affected Shelters**
walk(p_clusters7,~print(.x))
```


```{r,eval=F,out.width="100%"}
# and  **5 clusters** plotted against **Number affected Shelters**
walk(p_clusters5,~print(.x))
```

```{r, eval =F , out.width="100%"}
tar_load(return_period_levels)
tar_load(cccm_site_chirp_stats)
tar_load(cccm_wb)
site_rainfall_historical <- cccm_site_chirp_stats %>% 
    left_join(cccm_wb$`ML- Flooding Available data`%>% distinct(site_id, governorate_name))

p_precip_and_events_by_clust1$Hajjah
p_precip_and_events_by_clust1 <- 
    pmap(.l=list(df_clusters5,
                 return_period_levels$roll10,
                 zonal_stats_high_risk_hull$roll10 %>% 
                     split(.$governorate_name),
                 names(df_clusters5)),\(dfsf,rps,zonal_rf,nm){
                     
                     rps <- rps %>% 
                         mutate(
                             label= glue("{RP} year return period level: {round(estimate,1)} mm")
                         )
        
        df_w_damage <- dfsf %>% 
            st_drop_geometry() %>% 
            distinct(date,site_id,cluster) %>% 
            left_join(y = cccm_flood_impact_data %>%
                          group_by(site_id, date=date_of_episode) %>% 
                          summarise(
                              across(starts_with("num_"),~mean(.x,na.rm=T))
                          ) ,
                      by = c("site_id"="site_id","date"="date")) 
        
        date_range <- range(df_w_damage$date)
        dates_incl <- as_date(seq(date_range[1],date_range[2], by ="days"))
        date_center <-  median(dates_incl)
        zonal_rf_filt <- zonal_rf %>% 
            filter(as_date(ymd(date)) %in% dates_incl) %>% 
            mutate(cluster =NA)

        rainfall_tbl_filtered <- gov_area_rainfall_impact_tbl %>% 
            filter(governorate_name==nm,
                   date %in% dates_incl
                   ) 
        df_w_damage %>% 
            ggplot(aes(x=as_date(date),y=num_shelters_affected,color=cluster))+
            geom_point()+
            # geom_line(data=rainfall_tbl_filtered %>% mutate(cluster=NA),
            #           aes(x=as_date(date),y=precip_roll10_mean*25))+
            geom_line(data=zonal_rf_filt %>% mutate(cluster=NA),
                      aes(x=as_date(date),y=median*25))+
            geom_hline(data= rps,aes(yintercept = estimate*25))+
            geom_text(data=rps %>% 
                          mutate(cluster=NA), 
                       
                      aes(x=ymd(date_center),
                          y =(estimate*25)+(3*25),
                          label = label)
                      )+
            scale_y_continuous(sec.axis= sec_axis(trans=~.*(1/25),name="precip (10 day)"))+
            scale_x_date(breaks = "1 month",date_labels = "%b-%y" )+
        
            labs(y="Number affected Shelters",
                 title = "Clustering of events based on timing and coordinates",
                 subtitle = glue("Yemen - {nm} -5 clusters"))+
            theme_hdx()+
            theme(
                axis.title.x = element_blank(),
                axis.text.x = element_text(angle=90)
            )
            
        
    })

walk(p_precip_and_events_by_clust1, ~print(.x))
```




### Cluster Plots

```{r}

return_period_level_tibble <- function(df,value="mean",date="date",rp_year=c(2,3,4,5,10)){
    df_year_max <- df %>% 
        group_by(governorate_name,year=year(!!sym(date))) %>% 
        summarise(
            across(c("mean","median"),~max(.x,na.rm = T)),.groups = "drop"
        )
    
    gev_fit <- fevd(df_year_max[[value]], type = "GEV")
    return_levels_ci<- return.level(x = gev_fit, 
                                    return.period =rp_year,
                                    do.ci = TRUE, 
                                    alpha = 0.05)
    tibble(
        RP =rp_year,
        estimate_low= xyz.coords(return_levels_ci)$x,
        estimate_upp= xyz.coords(return_levels_ci)$z,
        estimate= xyz.coords(return_levels_ci)$y
    )
}


# historical rainfall = data set with historical rainfall
# from historical data set with ARIs
plot_rainfall_rps_impact <- function(impact_data=cccm_flood_impact_data_w_coords,
         historical_rainfall=zonal_stats_high_risk_hull,
         precip_regime= 'roll10',
         impact_var, 
         rp_year,
         scale=F,
         k=5,
         aggregate_impact =NULL){
    
    
    historical_rainfall_df <- historical_rainfall[[precip_regime]]
    historical_rainfall_df$labels <- paste0(
                "<br> date: ",historical_rainfall_df$date,
                "<br> precip: ", round(historical_rainfall_df$mean,1)
            ) %>% lapply(htmltools::HTML)
    
    historical_rainfall_list <-  historical_rainfall_df %>% 
                     split(.$governorate_name)
    
    impact_data_filtered <- impact_data %>% 
        rename(date= date_of_episode) %>% 
        group_by(governorate_name,site_id, lon,lat,date= ymd(date)) %>%
        # there are some cases where the same event was reported 2x by different 
        # agencies -- therefore we should sum these figs
        summarise(
            across(starts_with("num_"),~mean(.x,na.rm=T)),.groups="drop"
        ) %>%
        filter(governorate_name %in% c("Marib","Hajjah")) 
    
 
    
    pt_cluster_list<- spatial_pt_clusters(df = impact_data_filtered,
                        date = "date",
                        lon = "lon",
                        lat = "lat",
                        k=k,
                        event = NULL, # all events in this dataset
                        # impact_var = "num_shelters_affected",
                        # rp_year = c(2,3,4,5,10),
                        scale = scale) %>% 
        map(\(pt_sf){
            pt_df <- pt_sf %>% 
                st_drop_geometry()
            pt_df$pt_labels= paste0(
            "Site_ID:", pt_df$site_id,
            "<br> date:",pt_df$date,
            "<br> cluter:", pt_df$cluster,
            "<br> Shelters affected: ", pt_df$num_shelters_affected,
            "<br> Number HHs verified: ", pt_df$num_verified_hhs
        ) %>% lapply(htmltools::HTML)
            return(pt_df)
        }
            
            )
    
    
    cluster_palette <-  RColorBrewer::brewer.pal(n = k,name = "Spectral")
  
    map2(pt_cluster_list, historical_rainfall_list,\(impact,rainfall){
        pt_size <- 2
        if(!is.null(aggregate_impact)){
            impact <- impact %>% 
                group_by(governorate_name,cluster) %>%
                summarise(
                    min_date= min(date),
                    max_date= max(date),
                    date= median(date),
                    across(starts_with("num_"),~sum(.x,na.rm=T)),
                    num_events = n(),
                    .groups="drop"
                )
            impact$pt_labels <-  paste0(
                "<br> cluter: ", impact$cluster,
                "<br> date: ",impact$date,
                "<br> First date: ",impact$min_date,
                "<br> Last date: ",impact$max_date,
                "<br> Shelters affected: ", impact$num_shelters_affected,
                "<br> Number HHs verified: ", impact$num_verified_hhs,
                "<br> Number events: ", impact$num_events
            ) %>% lapply(htmltools::HTML)
            
            impact_var <- ifelse(aggregate_impact=="num_events","num_events",impact_var)
            pt_size <- 5
            
        }
        
        # to keep cluster colors from changing?
        named_cluster_palette <- cluster_palette %>% 
            set_names(
                impact %>% 
                    mutate(cluster_num = parse_number(cluster)) %>% 
                    distinct(cluster_num,cluster) %>% 
                    arrange(cluster_num) %>% 
            pull(cluster) %>% 
            unique() )
        
        return_level_tbl <- return_period_level_tibble(df = rainfall,value = "mean",date = "date",rp_year = rp_year)
        return_level_tbl <- return_level_tbl %>% 
            mutate(
                label= glue("{RP} year return period level: {round(estimate,1)} mm")
            )
        
        date_range <- range(impact$date)
        date_incl <-  seq((date_range[1]-30),(date_range[2]+30), by ="day")
        date_center <-  median(date_incl)
        rainfall_filt <- rainfall %>% 
            mutate(date = ymd(date)) %>% 
            filter(date %in% date_incl)
        max_rainfall <- max(rainfall_filt$mean,na.rm=T)
        max_impact <-  max(impact[[impact_var]],na.rm=T)
        scale_y <-  max_impact/max_rainfall
        nm <- unique(impact$governorate_name)
        
        if(is.null(aggregate_impact)){
            p <- ggplot(
                data= rainfall_filt,
                aes(x=date, y=mean ))+
                geom_line()+
                geom_point_interactive(aes(tooltip = labels), size = 0.05)+
                geom_hline(yintercept = return_level_tbl$estimate)+
                geom_text(data=return_level_tbl,
                          aes(x=ymd(date_center),
                              y =estimate+1.5,
                              label = label)
                )+
                geom_point_interactive(data= impact,
                                       aes(
                                           x=date,
                                           y=!!sym(impact_var)*(1/scale_y),
                                           color=cluster , 
                                           tooltip=pt_labels),
                                       size=pt_size)+
                scale_color_manual(values= named_cluster_palette)+
                scale_y_continuous(sec.axis= sec_axis(trans=~.*scale_y,name=impact_var))+
                scale_x_date(breaks = "1 month",date_labels = "%b-%y" )+
                labs(y=glue("Precip ({precip_regime} mm)"),
                     title = "Yemen Rainfall and Impact",
                     subtitle = glue("Yemen - {nm}"))+
                theme_hdx()+
                theme(
                    axis.title.x = element_blank(),
                    axis.text.x = element_text(angle=90)
                )
            
        }
        if(!is.null(aggregate_impact)){
            p <- ggplot(
                data= rainfall_filt,
                aes(x=date, y=mean ))+
                geom_line()+
                geom_point_interactive(aes(tooltip = labels), size = 0.05)+
                geom_hline(yintercept = return_level_tbl$estimate)+
                geom_text(data=return_level_tbl,
                          aes(x=ymd(date_center),
                              y =estimate+1.5,
                              label = label)
                )+
                 geom_point_interactive(data= impact,
                                       aes(
                                           x=date,
                                           y=!!sym(impact_var)*(1/scale_y),
                                           color=cluster ,
                                           tooltip=pt_labels
                                           ),
                                       size=pt_size)+
                scale_color_manual(values= named_cluster_palette)+
                scale_y_continuous(sec.axis= sec_axis(trans=~.*scale_y,name=impact_var))+
                scale_x_date(breaks = "1 month",date_labels = "%b-%y" )+
                
                labs(y=glue("Precip ({precip_regime} mm)"),
                     title = "Yemen Rainfall and Impact",
                     subtitle = glue("Yemen - {nm}"))+
                theme_hdx()+
                theme(
                    axis.title.x = element_blank(),
                    axis.text.x = element_text(angle=90)
                )
            
        }
        return(ggiraph::girafe(ggobj=p))
        
    }
    ) %>% 
        set_names(names(pt_cluster_list))
}
```


```{r}

# remove 1 site neither in Hajjah or Marib
cccm_flood_impact_data_ready <- cccm_flood_impact_data_w_coords %>% 
    filter(site_id !="YE1712_0643")

p_rainfall_rp_impact_num_shelters <- zonal_stats_high_risk_hull %>%
    names() %>% 
    map(\(precip_windows){
        plot_rainfall_rps_impact(impact_data=cccm_flood_impact_data_ready,
                         historical_rainfall=zonal_stats_high_risk_hull,
                         precip_regime= precip_windows,
                         impact_var = "num_shelters_affected",
                         rp_year= c(2,3,4,5, 10),
                         scale=F,
                         k=5,
                         aggregate_impact = NULL
                         )
        
    }) %>% 
    set_names(zonal_stats_high_risk_hull %>%
    names() )



p_rainfall_rp_impact_num_shelters_agg <- zonal_stats_high_risk_hull %>%
    names() %>% 
    map(\(precip_windows){
        plot_rainfall_rps_impact(impact_data=cccm_flood_impact_data_ready,
                         historical_rainfall=zonal_stats_high_risk_hull,
                         precip_regime= precip_windows,
                         impact_var = "num_shelters_affected",
                         rp_year= c(2,3,4,5, 10),
                         scale=F,k=5,
                         aggregate_impact = "total"
                         )
        
    }) %>% 
    set_names(zonal_stats_high_risk_hull %>%
    names() )


p_rainfall_rp_impact_num_events_agg <- zonal_stats_high_risk_hull %>%
    names() %>% 
    map(\(precip_windows){
        plot_rainfall_rps_impact(impact_data=cccm_flood_impact_data_ready,
                         historical_rainfall=zonal_stats_high_risk_hull,
                         precip_regime= precip_windows,
                         impact_var = "num_shelters_affected",
                         rp_year= c(2,3,4,5, 10),
                         scale=F,k=5,
                         aggregate_impact = "num_events"
                         )
        
    }) %>% 
    set_names(zonal_stats_high_risk_hull %>%
    names() )


```

```{r, eval=FALSE}

# exploring issues in marib
cccm_flood_impact_data_ready %>% 
    mutate(
        date= ymd(date_of_episode)
    ) %>% 
    filter(governorate_name=="Marib") %>% 
    filter(month(date)%in%c(4)) %>% 
    select(
        governorate_name,district_name,
        site_id,site_name,
           date, starts_with("num_"))

cccm_flood_impact_data_ready %>% 
    st_drop_geometry() %>% 
    mutate(
        date= ymd(date_of_episode)
    ) %>% 
    filter(
        site_id =="YE2613_1961"
    ) %>% 
    View()
    glimpse()
    ```



#### Hajjah Grouped By Event

- number shelters affected

```{r, out.width="100%"}
hajjah_event_plots <- modify_depth(p_rainfall_rp_impact_num_shelters, 1, "Hajjah")
marib_event_plots <- modify_depth(p_rainfall_rp_impact_num_shelters, 1, "Marib")
```


```{r, out.width="100%"}

htmltools::tagList(hajjah_event_plots)

```

#### Marib Grouped By Event

- number shelters affected

```{r, out.width="100%"}
htmltools::tagList(marib_event_plots)
# walk(marib_event_plots,~print(.x))
```

#### Hajjah Grouped By Cluster

- Number of shelters affected aggregated by cluster
```{r, out.width="100%"}

hajjah_cluster_shelter_plots <- modify_depth(p_rainfall_rp_impact_num_shelters_agg, 1, "Hajjah")
hajjah_cluster_event_plots <- modify_depth(p_rainfall_rp_impact_num_events_agg, 1, "Hajjah")
marib_cluster_event_plots <- modify_depth(p_rainfall_rp_impact_num_events_agg, 1, "Marib")
marib_cluster_shelter_plots <- modify_depth(p_rainfall_rp_impact_num_shelters_agg, 1, "Marib")
walk(hajjah_cluster_shelter_plots,~print(.x))
```

- Number events aggregated by cluster
```{r, out.width="100%"}
# walk(hajjah_cluster_event_plots,~print(.x))
htmltools::tagList(hajjah_cluster_event_plots)
```

#### Marib Grouped By Cluster

- Number of shelters affected aggregated by cluster
```{r, out.width="100%"}
# walk(marib_cluster_shelter_plots,~print(.x))
htmltools::tagList(marib_cluster_shelter_plots)
```

- Number events aggregated by cluster

```{r, out.width="100%"}
htmltools::tagList(marib_cluster_event_plots)
```


```{r,eval=F}

# are any of them the same sites in july/aug? -- no
df_clusters5$Hajjah %>% 
    st_drop_geometry( ) %>% 
    filter(month(date) %in% c(7,8)) %>% 
    group_by(site_id) %>% 
    filter(n()>1)


# 
```

```{r,eval =F }
classify_events <-  function(df_cluster=df_clusters5$Hajjah %>% 
                                 st_drop_geometry(),
                             impact_table=rainfall_impact_tbl,
                             x= "precip_roll10_mean"{
    rainfall_impact_summarised_by_date <- rainfall_impact_tbl %>% 
        group_by(date) %>% 
        summarise(across(starts_with("precip_"),list(mean=mean,max=max)))
    df_cluster_split <-  split(df_cluster,df_cluster$cluster) %>% 
        map(\(cluster_subset){
            cluster_subset %>% 
                select(site_id, date, fevent_cluster=fevent) %>% 
                right_join(rainfall_impact_summarised_by_date) %>% 
                mutate(
                    fevent_cluster= replace_na(fevent_cluster,F)
                )
            })
    max_rainfall <- ceiling(max(rainfall_impact_summarised_by_date[[x]],na.rm=T))
    thresholds_iter <-  seq(0,max_rainfall,by=1)
    clusters_classified <- df_cluster_split %>% 
        map(\(cluster_subset){
            thresholds_iter %>% 
            map(\(thresh_temp){
                  calc_TPFPFN(df=cluster_subset ,
                            x=x,
                            event ="fevent_cluster" ,
                            thresh = thresh_temp,
                            look_ahead = 7,
                            look_back = 7)
                
            })
              
            
        }
        )
    
    clusters_classified$Hajjah_1 %>% 
        map("FPs")
    fp_1 <- Reduce('|',clusters_classified$Hajjah_1 %>% map("FPs"))
    
    
    clusters_classified %>% 
        
    clusters_classified %>% 
        keep_at(at = ~str_detect(.x, "FPs"))
    # need to flatten FPs
    FP_ret_combined<- Reduce('|',clusters_classified %>% map("FPs"))
    reduce(clusters_classified$)
}


```


```{r,eval = F }

# i want a FP date search that gets all the dates from summmarised df and makes list of lists for date
# before, betwen, after, all the tp dates
get_tp_dates <- function(df,
                         date,
                         lon,
                         lat,
                         event,
                         k,
                         look_back,
                         look_ahead,
                         scale=T
                         ){
    
     # df_events_clustered <- kmeans_cluster_events(df = df,
     #                  date = date,
     #                  lon=lon,
     #                  lat=lat,
     #                  event=event,
     #                  k=k)
    df_events_clustered <- spatial_pt_clusters(df = df,
                date =date,
                lon = lon,
                lat=lat,
                event = event,
                scale = scale,
                k = k) %>% 
        st_drop_geometry()
    
    search_dates_for_thresh <- df_events_clustered %>% 
        group_split(cluster) %>% 
         map(\(df_clust){
        event_date_range <- df_clust %>% 
            pull(date) %>% 
            range()
        start_search <- min(event_date_range)-look_back
        end_search <- max(event_date_range)+look_ahead
        seq(start_search,end_search,by="day")
    }
    )
    
}

classify_events <- function(df,
         look_ahead=7,
         look_back=7, 
         date = "date",
         lon="lon",
         lat="lat",
         event="fevent",
         k=5,
         scale,
         precip_regime="precip_roll10_mean"
         ){
         
    
    df_summarised <- df %>% 
        group_by(date) %>% 
        summarise(across(starts_with("precip_"),list(mean=mean,max=max)))
    
    event_search_dates <- get_tp_dates(df=df,
                                       date=date,
                                       lon=lon,
                                       lat=lat,
                                       look_back=look_back,
                                       look_ahead= look_ahead,
                                       event=event,
                                       scale=scale,
                                       k=k)

    max_rainfall <- ceiling(max(df_summarised[[precip_regime]],na.rm=T))
    thresholds_iter <- seq(0,max_rainfall,by=1)
     
    events_classified <- 
        thresholds_iter %>% 
        map_dfr(\(thresholds){
            event_search_dates %>% 
        map_dfr(\(search_dts){
            df_time_filt <- df_summarised %>% 
                filter(date %in% search_dts) 
            if(any(df_time_filt[[precip_regime]]>=thresholds)){
                ret <- data.frame(start_date = min(search_dts),end_date= max(search_dts),class_event = "TP")
            }else{
                ret <- data.frame(start_date = min(search_dts),end_date= max(search_dts),class_event="FN")
            }
        ret %>% 
            mutate(threshold=thresholds)
            }
        
        )
            
        })
        
    
    return(events_classified)
    
}

ck <- classify_events(df =rainfall_impact_tbl %>% 
                          filter(governorate_name =="Hajjah"),
                look_ahead = 7,
                look_back = 7,
                date = "date",
                lon = "lon",
                lat = "lat",
                event = "fevent",
                k = 5,
                precip_regime = "precip_roll10_mean")

ck %>% 
    group_by(threshold=as_factor(threshold),
             class_event,
             .drop=F) %>% 
    count() %>%
    ungroup() %>% 
    complete(class_event,threshold,fill=list(n=0)) %>%
    arrange(threshold) %>%
    # filter(threshold %in% c(4:7)) %>%
    # filter(class_event=="TP")

    ggplot(aes(x=threshold, y=n, color= class_event, group=class_event))+
    geom_line()+
    theme_bw()+
    theme(
        axis.text.x = element_text(angle=90)
    )
    
```

## Cluster Performance

```{r}
events_clustered <- spatial_pt_clusters(df=cccm_impact_c1,
                                        date = "date",
                                        lon = "lon",
                                        lat="lat",
                                        k=5,
                                        event = NULL,
                                        scale=F) %>% 
    map(
        ~st_drop_geometry(.x)
    )
ex_cldf <- events_clustered$Hajjah %>% 
    split(.$cluster) 
ex_cldf <- ex_cldf$Hajjah_4  %>% st_drop_geometry()

rainfall_hajjah = zonal_stats_high_risk_hull$roll10 %>% 
    split(.$governorate_name) %>% 
    keep_at(~.x =="Hajjah")
rainfall_hajjah <- rainfall_hajjah %>% unname() %>% data.frame()

classify_cluster <- function(df,
                             rainfall,
                             rainfall_value= "mean",
                             thresh=25,
                             date= "date",
                             look_ahead=7,
                             look_back=7){
    
    start_search <- as_date(min(as_date(df[[date]]),na.rm=T)-look_back)
    end_search <- as_date(max(as_date(df[[date]]),na.rm=T)+look_ahead)
    date_incl <- seq(start_search,end_search,by="day")
   
     rainfall_filt <- rainfall %>% 
        filter(as_date(date) %in% date_incl)
    
    if(any(rainfall_filt[[rainfall_value]]>=thresh)){
        data.frame(
            threshold = thresh,
            classification = "TP"
            
        )
    }else{
         data.frame(
            threshold = thresh,
            classification = "FN"
            
        )
        
    }
}
get_exclusion_dates <-  function(df=events_clustered$Hajjah %>% 
                                     st_drop_geometry(),
                          date="date", 
                          look_back=7, look_ahead=7){
    event_dates <- df %>% 
        mutate(
            date= as_date(!!sym(date))
        ) %>% 
        group_by(cluster) %>% 
        summarise(
            min_date = min(date)- look_back,
            max_date = max(date)+look_ahead,groups="drop",
            dates_included = list(seq(min_date,max_date, by ="day"))
        ) %>% 
        pull(dates_included) %>% 
        unlist()%>% 
        unique() %>% 
        as_date() %>% 
        sort()
    
}

# debugonce(classify_events_now)
boom <- classify_events_now(impact = bind_rows(events_clustered),
                    rainfall = zonal_stats_high_risk_hull,
                    precip_regime = "roll10",
                    date = "date",
                    look_ahead = 7,
                    look_back = 7
                    )

boom$Hajjah$eval_ratios %>% pull(ratio)
boom %>% 
    map(
        \(summary_class_tbl){
            summary_class_tbl$class_freq %>%  
                ggplot(aes(x= threshold, 
                           y= n ,
                           color= classification, 
                           group= classification))+
                geom_line()+
                geom_line(data= summary_class_tbl$eval_ratios,
                          aes(x=threshold, y=ratio*10,color=eval_ratio,group=eval_ratio)
                )+
                scale_y_continuous( sec.axis = sec_axis(trans =~.*(1/10), name="ratio"))+
                theme_hdx()
        }
    )
    

#' Title
#'
#' @param impact data.frame containing events, dates, and clusters
#' @param rainfall list
#' @param precip_regime 
#' @param date 
#' @param look_back 
#' @param look_ahead 
#' @param plot 
#'
#' @return
#' @export
#'
#' @examples
classify_events_now <- function(impact,
                                rainfall,
                                precip_regime="roll10",
                                date,
                                look_back,
                                look_ahead,
                                plot=F
                                ){
    
    rainfall_split <-  rainfall[[precip_regime]] %>% 
    split(.$governorate_name) 
    
    impact_split <-  impact %>% 
    split(.$governorate_name) 
    
    performance_metrics <- map2(impact_split,rainfall_split,\(cluster_gov_df,rainfall_df){
        rainfall_df <- rainfall_df %>% 
            arrange(date) %>% 
            mutate(
                idx = row_number()
            )
        
            cluster_gov_df <- cluster_gov_df %>% 
                mutate(date= as_date(!!sym(date)))
        
            excl_dates<- get_exclusion_dates(df = cluster_gov_df,
                                             date = date, 
                                             look_back = look_back,
                                             look_ahead = look_ahead )
            
            date_range <-  range(cluster_gov_df[[date]],na.rm=T)
            date_range_incl <-  seq(date_range[1]-look_back,date_range[2]+look_ahead, by ="days")
            
            # df filtered for TP/FN classification
            rainfall_filt <- rainfall_df %>% 
                mutate(
                    date= as_date(!!sym(date))
                ) %>% 
                filter(date %in% date_range_incl)
            
            # df  filtered for FP classification
            rainfall_fp_df <- rainfall_filt %>% 
                filter(!date %in% excl_dates) %>% 
                arrange(date)
            
            max_rainfall <-  ceiling(max(rainfall_filt$mean,na.rm=T))
            
            # classification of events (TP/FN) is done per cluster
            events_classified <- cluster_gov_df %>% 
                split(.$cluster) %>% 
                # and for all thresholds
                imap_dfr(\(single_cluster_df,clust_name){
                    seq(0,max_rainfall, by =1) %>% 
                        map_dfr(\(threshold){
                           classify_cluster(df= single_cluster_df,
                                             rainfall= rainfall_filt,
                                            thresh = threshold,
                                            look_ahead = look_ahead ,
                                            look_back=look_back) %>% 
                                mutate(cluster= clust_name)
                        })
                }) # end double inner mapper
            
            tpfn_summary <- events_classified %>% 
                mutate(classification=as_factor(classification)) %>% 
                group_by(threshold,classification,.drop=F) %>% 
                summarise(
                    n= n() ,
                    .groups="drop"
                )
                    
                          
            # need a separate mapping process for FPs
            fp_summary <- seq(0,max_rainfall, by =1) %>% 
                map_dfr(\(threshold){
                    
                    # use index to break vector into lists where each item 
                    # contains the consecutive run.
                    idx <- rainfall_fp_df$idx
                    # find break points
                    idx_split_idx <- c(1, which(diff(idx) > (1)) + 1, 
                                          length(idx) + 1)
                    idx_lists <- split(idx,cumsum(seq_along(idx) %in% idx_split_idx))
                    
                    # for each list apply criteria for FP classsificatin
                    fp_df <- idx_lists %>% 
                        map_dfr(\(idx_set){
                                gte_thresh <- rainfall_fp_df[idx%in% idx_set,][["mean"]]>=threshold
                                idx_gte_thresh<- idx_set[gte_thresh]
                                starts_lgl <- diff(c(0,idx_gte_thresh))>1
                                idx_starts <- idx_gte_thresh[starts_lgl]
                                num_fps<- length(idx_starts)
                                tibble(
                                    threshold = threshold,
                                    classification = "FP",
                                    n = num_fps
                                )
                        }) # end inner mapper
                    fp_df %>% 
                        group_by(threshold, classification) %>% 
                        summarise(
                            n= sum(n,na.rm = T),.groups="drop"
                        )
                    
                }) # end outer mapper
                                
            class_freq <- bind_rows(tpfn_summary,fp_summary) %>% 
                arrange(threshold)
            
            evaluation_ratios <- class_freq %>% 
                # group_by(threshold) %>% 
                pivot_wider(id_cols = threshold,
                            names_from = classification,
                            values_from = n
                ) %>% 
                mutate(precision = TP/(TP+FP),
                       recall = TP/(TP+FN)) %>%
                select(threshold, precision, recall) %>% 
                pivot_longer(cols=precision:recall,
                             names_to = "eval_ratio",
                             values_to= "ratio")
            ret <- list()
            ret$class_freq <- class_freq
            ret$eval_ratios <- evaluation_ratios
            return(ret)
            if(plot){
                
            }
                    
        }) # end outer map
        
    return(performance_metrics)
}


# need to finish this one - 
viz_cluster_classification <- function(impact,
                                rainfall,
                                precip_regime="roll10",
                                threshold,
                                date,
                                look_back,
                                look_ahead,
                                
                                ){
    
    rainfall_split <-  rainfall[[precip_regime]] %>% 
    split(.$governorate_name) 
    
    impact_split <-  impact %>% 
    split(.$governorate_name) 
    
    performance_metrics <- map2(impact_split,rainfall_split,\(cluster_gov_df,rainfall_df){
        rainfall_df <- rainfall_df %>% 
            arrange(date) %>% 
            mutate(
                idx = row_number()
            )
        
            cluster_gov_df <- cluster_gov_df %>% 
                mutate(date= as_date(!!sym(date)))
        
            excl_dates<- get_exclusion_dates(df = cluster_gov_df,
                                             date = date, 
                                             look_back = look_back,
                                             look_ahead = look_ahead )
            
            date_range <-  range(cluster_gov_df[[date]],na.rm=T)
            date_range_incl <-  seq(date_range[1]-look_back,date_range[2]+look_ahead, by ="days")
            
            # df filtered for TP/FN classification
            rainfall_filt <- rainfall_df %>% 
                mutate(
                    date= as_date(!!sym(date))
                ) %>% 
                filter(date %in% date_range_incl)
            
            # df  filtered for FP classification
            rainfall_fp_df <- rainfall_filt %>% 
                filter(!date %in% excl_dates) %>% 
                arrange(date)
            
            max_rainfall <-  ceiling(max(rainfall_filt$mean,na.rm=T))
            
            # classification of events (TP/FN) is done per cluster
            events_classified <- cluster_gov_df %>% 
                split(.$cluster) %>% 
                # and for all thresholds
                imap_dfr(\(single_cluster_df,clust_name){
                           classify_cluster(df= single_cluster_df,
                                             rainfall= rainfall_filt,
                                            thresh = threshold,
                                            look_ahead = look_ahead ,
                                            look_back=look_back) %>% 
                                mutate(cluster= clust_name)
                        })
                }) # end double inner mapper
            
            tpfn_summary <- events_classified %>% 
                mutate(classification=as_factor(classification)) %>% 
                group_by(threshold,classification,.drop=F) %>% 
                summarise(
                    n= n() ,
                    .groups="drop"
                )
                    
                          
            # need a separate mapping process for FPs
            fp_summary <- seq(0,max_rainfall, by =1) %>% 
                map_dfr(\(threshold){
                    
                    # use index to break vector into lists where each item 
                    # contains the consecutive run.
                    idx <- rainfall_fp_df$idx
                    # find break points
                    idx_split_idx <- c(1, which(diff(idx) > (1)) + 1, 
                                          length(idx) + 1)
                    idx_lists <- split(idx,cumsum(seq_along(idx) %in% idx_split_idx))
                    
                    # for each list apply criteria for FP classsificatin
                    fp_df <- idx_lists %>% 
                        map_dfr(\(idx_set){
                                gte_thresh <- rainfall_fp_df[idx%in% idx_set,][["mean"]]>=threshold
                                idx_gte_thresh<- idx_set[gte_thresh]
                                starts_lgl <- diff(c(0,idx_gte_thresh))>1
                                idx_starts <- idx_gte_thresh[starts_lgl]
                                num_fps<- length(idx_starts)
                                tibble(
                                    threshold = threshold,
                                    classification = "FP",
                                    n = num_fps
                                )
                        }) # end inner mapper
                    fp_df %>% 
                        group_by(threshold, classification) %>% 
                        summarise(
                            n= sum(n,na.rm = T),.groups="drop"
                        )
                    
                }) # end outer mapper
                                
            class_freq <- bind_rows(tpfn_summary,fp_summary) %>% 
                arrange(threshold)
            
            evaluation_ratios <- class_freq %>% 
                # group_by(threshold) %>% 
                pivot_wider(id_cols = threshold,
                            names_from = classification,
                            values_from = n
                ) %>% 
                mutate(precision = TP/(TP+FP),
                       recall = TP/(TP+FN)) %>%
                select(threshold, precision, recall) %>% 
                pivot_longer(cols=precision:recall,
                             names_to = "eval_ratio",
                             values_to= "ratio")
            ret <- list()
            ret$class_freq <- class_freq
            ret$eval_ratios <- evaluation_ratios
            return(ret)
                    }) # end outer map
        
    return(performance_metrics)
}


viz_cluster_classification <-  function()
# 
# seq(1:200) %>% 
#     map_dfr(
#         ~classify_cluster(df = ex_cldf,
#                  rainfall = tibble(rainfall_hajjah ),
#                  rainfall_value = "mean",
#                  thresh = .x,
#                  date = "date",
#                  look_ahead = 7,
#                  look_back = 7)
#     )


```

